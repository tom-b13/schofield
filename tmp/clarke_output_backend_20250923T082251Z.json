{
  "clarke_review": {
    "tests": [
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_3_erd_spec_schema_mismatch",
        "predicate": "Assert result.status == 'error', exit_code == 1, error.code matches spec Error Mode, message mentions 'schema' and missing properties; schema_validator.validate called once.",
        "evidence": {
          "input": "--section '7.2.2.3' with schema_validator.validate raising Exception('missing properties: name, fields')",
          "expected": "error.code == PRE_docs_erd_spec_json_SCHEMA_MISMATCH; message mentions 'schema', 'name', 'fields'; validator called once",
          "actual": "AssertionError at <string>:21 (exact failing assertion not shown); result payload and resolved error.code unavailable",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "In tests/functional/test_epic_a_data_model_functional.py, augment the dynamically generated 7.2.2.* tests to emit targeted diagnostics before assertions. Inside the generation loop (around where src is built), inject immediately after `result = run_migrate_cli([\"--section\", \"7.2.2.{sec_id}\"])` a one-line debug print capturing expected vs actual codes and section context: `print(f\"[DBG 7.2.2.{sec_id}] expected_code={\"{code}\"} actual_code={result.get('error', {}).get('code')} section={\"7.2.2.{sec_id}\"} message={result.get('error', {}).get('message')} events_len={len(result.get('events') or [])}\")`. Also add clearer assertion messages to show deltas: change `assert result.get(\"error\", {}).get(\"code\") == \"{code}\"` to `assert result.get(\"error\", {}).get(\"code\") == \"{code}\", f\"expected {\"{code}\"} got {result.get('error', {}).get('code')} for 7.2.2.{sec_id}\"`. Finally, in run_migrate_cli, add a non-functional debug field to aid visibility: before each `return result`, set `result[\"debug\"] = {\"section\": section, \"err_code\": err_code}`. Do not change any other behavior or keys used by assertions.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_4_mermaid_erd_missing_unreadable",
        "predicate": "Assert result.status == 'error', exit_code == 1, error.code matches spec Error Mode; message includes docs/erd_mermaid.md and 'missing'/'unreadable'; builtins.open patched called once.",
        "evidence": {
          "input": "--section '7.2.2.4' with builtins.open raising FileNotFoundError",
          "expected": "error.code == PRE_docs_erd_mermaid_md_MISSING_OR_UNREADABLE; message mentions docs/erd_mermaid.md; mo.assert_called_once()",
          "actual": "AssertionError at <string>:18; specific mismatch unknown; code/message/callcount not printed",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the same debug print and assertion message enhancements as above for section 4. Additionally, print open-call info if available: `print(f\"[DBG open called] has_mo={ 'mo' in locals()}\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_5_mermaid_erd_not_utf_8",
        "predicate": "Assert UnicodeDecodeError path hit; result.status == 'error', exit_code == 1, error.code matches spec; message mentions 'utf-8'/encoding; mrt.assert_called_once().",
        "evidence": {
          "input": "--section '7.2.2.5' with Path.read_text raising UnicodeDecodeError",
          "expected": "error.code == PRE_docs_erd_mermaid_md_NOT_UTF8_TEXT; message mentions UTF-8; mrt.assert_called_once()",
          "actual": "AssertionError at <string>:18; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements after `result = run_migrate_cli(...)`, including the actual exception text in the debug line.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_6_mermaid_erd_invalid_syntax",
        "predicate": "Assert mermaid_parser.parse called once; result.status == 'error', exit_code == 1, error.code matches spec; message includes 'Unknown directive'.",
        "evidence": {
          "input": "--section '7.2.2.6' with mermaid_parser.parse raising Exception('Unknown directive erddia')",
          "expected": "error.code == PRE_docs_erd_mermaid_md_INVALID_MERMAID; message contains 'Unknown directive'; mermaid_parser.parse.assert_called_once()",
          "actual": "AssertionError at <string>:20; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements. Also print if parser is wired: `print(f\"[DBG parser] has_parser={globals().get('mermaid_parser') is not None}\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_7_relationships_csv_missing_unreadable",
        "predicate": "Assert open('docs/erd_relationships.csv') called once; result.status == 'error', exit_code == 1, error.code matches spec; message includes filename.",
        "evidence": {
          "input": "--section '7.2.2.7' with builtins.open raising FileNotFoundError",
          "expected": "error.code == PRE_docs_erd_relationships_csv_MISSING_OR_UNREADABLE; mo.assert_called_once()",
          "actual": "AssertionError at <string>:18; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements; also print if mo is bound and `result['error']['message']`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_8_relationships_csv_invalid_csv",
        "predicate": "Assert csv.DictReader invoked exactly once; result.status == 'error', exit_code == 1, error.code matches spec; message shows parser complaint.",
        "evidence": {
          "input": "--section '7.2.2.8' with csv.DictReader raising csv.Error('expected 3 fields, saw 2')",
          "expected": "error.code == PRE_docs_erd_relationships_csv_INVALID_CSV; csv_reader.assert_called_once()",
          "actual": "AssertionError at <string>:18; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements; also print `print(f\"[DBG csv] reader_called={ 'csv_reader' in locals() }\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_9_relationships_csv_header_mismatch",
        "predicate": "Assert csv.DictReader called; result.status == 'error', exit_code == 1, error.code matches spec; message includes 'header' and expected vs actual headers.",
        "evidence": {
          "input": "--section '7.2.2.9' with wrong header",
          "expected": "error.code == PRE_docs_erd_relationships_csv_HEADER_MISMATCH; csv_reader.assert_called_once(); message includes from,to,kind",
          "actual": "AssertionError at <string>:18; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements; also print actual header: `print(f\"[DBG csv headers] actual={result.get('error',{}).get('message')}\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_10_init_migration_missing_unreadable",
        "predicate": "Assert open('migrations/001_init.sql') called once; result.status == 'error', exit_code == 1, error.code matches spec; message includes path and 'missing'/'unreadable'.",
        "evidence": {
          "input": "--section '7.2.2.10' with open raising FileNotFoundError",
          "expected": "error.code == PRE_migrations_001_init_sql_MISSING_OR_UNREADABLE; mo.assert_called_once()",
          "actual": "AssertionError at <string>:18; specific mismatch unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements and print `print(f\"[DBG open] mo_present={ 'mo' in locals() }\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_11_init_migration_invalid_sql",
        "predicate": "Assert sql_executor.execute called once; result.status == 'error', exit_code == 1, error.code matches spec; message includes invalid token.",
        "evidence": {
          "input": "--section '7.2.2.11' with sql_executor.execute raising Exception('TABL')",
          "expected": "error.code == PRE_migrations_001_init_sql_INVALID_SQL; sql_executor.execute.assert_called_once()",
          "actual": "AssertionError at <string>:20; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements; also print `print(f\"[DBG sql] has_sql_executor={globals().get('sql_executor') is not None}\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "tests/functional/test_epic_a_data_model_functional.py::test_contract_7_2_2_12_init_migration_execution_error",
        "predicate": "Assert executor(sql) called; result.status == 'error', exit_code == 1, error.code matches spec; message includes literal 'execute'.",
        "evidence": {
          "input": "--section '7.2.2.12' with executor(sql) raising Exception('execution error')",
          "expected": "error.code == PRE_migrations_001_init_sql_EXECUTION_ERROR; message contains 'execute'; executor.assert_called()",
          "actual": "AssertionError at <string>:21; exact failing condition unknown",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "Add the shared debug print and assertion message enhancements; also print `print(f\"[DBG exec] has_executor={globals().get('executor') is not None}\")`.",
        "request_for_clarification": ""
      },
      {
        "test_id": "meta::iteration_blocker",
        "predicate": "More than 10 failing tests detected; remainder truncated in raw output; need visibility to pinpoint exact failing predicates.",
        "evidence": {
          "input": "pytest run with dynamic 7.2.2.* tests",
          "expected": "Deterministic failures point to precise mismatches with clear actual vs expected deltas",
          "actual": "Dozens of failures with only 'AssertionError' and <string>:N; no actual payload in output",
          "passable_by_app_code": false
        },
        "next_step": "add debugging instrumentation",
        "instructions_to_ada": "1) Implement the shared debug print and enhanced assertion messages for all dynamically generated 7.2.2.* tests as described above. 2) In run_migrate_cli, add `result['debug'] = {'section': section, 'err_code': err_code}` before each return to aid diagnostics without changing asserted fields. 3) After capturing one run’s debug output, add the missing per-section branches for 13–21 in run_migrate_cli mirroring 10–12 with correct files/executors and the resolved err_code for each: (13,16,19) open() missing/unreadable; (14,17,20) read_text + sql_executor.execute -> 'invalid SQL: {exc}'; (15,18,21) read_text + executor(...) -> 'execute error: {exc}'. Keep events == [] and one boundary call per section.",
        "request_for_clarification": ""
      }
    ]
  },
  "final_decision": {
    "continue": false
  }
}