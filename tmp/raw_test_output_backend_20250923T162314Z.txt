============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/codex/schofield
plugins: mock-3.14.1, anyio-4.9.0, cov-6.2.1, langsmith-0.4.1
collected 190 items

tests/architectural/test_epic_a_data_model_architecture.py ............. [  6%]
..............                                                           [ 14%]
tests/functional/test_epic_a_data_model_functional.py .................. [ 23%]
.................x......................FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 61%]
FFFFF.F.F.F..F..F.F.....FFFFFFFFFFFFFFFFFFFFFF........F..F..F..F..F...F. [ 99%]
.                                                                        [100%]

=================================== FAILURES ===================================
____________________ test_7_2_2_22_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079aa17e0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078cb8e80>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078cb8e80> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_23_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078aaa5c0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078b9c640>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078b9c640> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_24_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079b0ef50>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078c22cc0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078c22cc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_25_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079742200>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078fbf0c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078fbf0c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_26_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079cd1750>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f90793cb4c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f90793cb4c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_27_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079a335e0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079a5ac40>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079a5ac40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_28_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b8ab30>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078c44ac0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078c44ac0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_29_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079a9ef50>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078a0b400>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078a0b400> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_30_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f90789d8be0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f90789ee9c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f90789ee9c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_31_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079c531c0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078d27280>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078d27280> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_32_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079aa3be0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078d37b00>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078d37b00> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_33_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078a539a0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078b9c840>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078b9c840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_34_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079b0f580>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078edc800>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078edc800> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_35_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079cd3460>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078a8b840>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078a8b840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_36_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078982ef0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f90794724c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f90794724c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_37_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079a51d50>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078b74bc0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078b74bc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_38_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079caf5b0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079a34040>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079a34040> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_39_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b6c130>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078a0abc0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078a0abc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_40_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b534f0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079c40400>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079c40400> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_41_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b88e80>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f90789a6e00>('exit_code')
E        +    where <built-in method get of dict object at 0x7f90789a6e00> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_42_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078a93fa0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078d37c80>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078d37c80> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_43_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079aadf00>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079625e40>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079625e40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_44_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f90789802b0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f907931c080>('exit_code')
E        +    where <built-in method get of dict object at 0x7f907931c080> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_45_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078c07730>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078a21fc0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078a21fc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_46_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079a52440>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078b18e40>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078b18e40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_47_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b8b1c0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078977980>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078977980> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_48_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b83340>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079dc1480>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079dc1480> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_49_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078aa9cc0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078bd0840>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078bd0840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_50_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078a51d20>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078c2f680>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078c2f680> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_51_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9079742320>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078ba82c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078ba82c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_52_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078981a20>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079a297c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079a297c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_53_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b6e3e0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f90789e3100>('exit_code')
E        +    where <built-in method get of dict object at 0x7f90789e3100> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_54_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078980190>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078a0de40>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078a0de40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_55_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078a506a0>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078eba440>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078eba440> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_56_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b83490>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9079c409c0>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9079c409c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
____________________ test_7_2_2_57_enhanced_error_semantics ____________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7f9078b88370>

    def _t(mocker) -> None:
        # Apply boundary patch using object-based strategy where possible
        patch_path = _cfg["patch"]
        mocked = None
        try:
            if patch_path.startswith("app.db.base."):
                import app.db.base as base  # type: ignore
                obj = base
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                # Ensure container exists for attribute
                container = getattr(base, patch_path.split(".")[2], None)
                if container is None:
                    setattr(base, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(base, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            elif patch_path.startswith("app.db.migrations_runner."):
                import app.db.migrations_runner as mr  # type: ignore
                obj = mr
                for part in patch_path.split(".")[3:-1]:
                    obj = getattr(obj, part, obj)
                attr = patch_path.split(".")[-1]
                container = getattr(mr, patch_path.split(".")[2], None)
                if container is None:
                    setattr(mr, patch_path.split(".")[2], types.SimpleNamespace())
                target = getattr(mr, patch_path.split(".")[2])
                mocked = mocker.patch.object(target, attr, create=True)
            else:
                import tests.functional.test_epic_a_data_model_functional as mod
                mapping = {
                    "app.resolution.engine.Resolver.resolve_placeholders": (mod.Resolver, "resolve_placeholders"),
                    "app.net.resolver.resolve_host": (mod.resolver, "resolve_host"),
                    "app.encryption.accessor.read_encrypted_field": (mod.accessor, "read_encrypted_field"),
                    "app.encryption.kms.get_key": (mod.kms, "get_key"),
                    "app.encryption.decrypt": (mod.encryption, "decrypt"),
                    "app.cache.store.save": (mod.cache.store, "save"),
                    "app.secrets.manager.get": (mod.secrets.manager, "get"),
                    "app.logging.logger.error": (mod.logger, "error"),
                    "app.fs.tmp.allocate": (mod.fs.tmp, "allocate"),
                    "app.telemetry.emit_error": (mod.telemetry, "emit_error"),
                }
                if patch_path in mapping:
                    obj, attr = mapping[patch_path]
                    mocked = mocker.patch.object(obj, attr, create=True)
                else:
                    # Fallback to string-based patch as last resort
                    mocked = mocker.patch(patch_path, create=True)
        except Exception:
            # Ensure a mocked object exists to preserve call count assertions
            mocked = mocker.patch(patch_path, create=True)
        res = run_migrate_cli(["--section", _sid])
        # Standard error assertions via mapping
        code = SECTIONS_722.get(_sid, "EXPECTED_ERROR_CODE_FROM_SPEC")
        assert res.get("status") == "error"
        assert (res.get("error", {}) or {}).get("code") == code
>       assert res.get("exit_code") == 1
E       AssertionError: assert None == 1
E        +  where None = <built-in method get of dict object at 0x7f9078e9e100>('exit_code')
E        +    where <built-in method get of dict object at 0x7f9078e9e100> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get

tests/functional/test_epic_a_data_model_functional.py:2146: AssertionError
__________________ test_7_2_2_58_outputs_entities_incomplete ___________________

    def test_7_2_2_58_outputs_entities_incomplete():
        """Verifies 7.2.2.58  Outputs: entities incomplete."""
        outputs = _get_outputs_for_contract()
        entities = outputs.get("entities")
>       assert entities is not None  # ensure presence
E       assert None is not None

tests/functional/test_epic_a_data_model_functional.py:2188: AssertionError
______________ test_7_2_2_60_outputs_entities_mutable_within_step ______________

    def test_7_2_2_60_outputs_entities_mutable_within_step():
        """Verifies 7.2.2.60  Outputs: entities mutable within step."""
        outputs1 = _get_outputs_for_contract()
        outputs2 = _get_outputs_for_contract()
        # Both snapshots must be present and equal within the same step
>       assert outputs1 and outputs2 and outputs1 == outputs2
E       assert ({})

tests/functional/test_epic_a_data_model_functional.py:2205: AssertionError
_____________ test_7_2_2_62_outputs_entity_name_mismatch_with_erd ______________

    def test_7_2_2_62_outputs_entity_name_mismatch_with_erd():
        """Verifies 7.2.2.62  Outputs: entity name mismatch with ERD."""
        outputs = _get_outputs_for_contract()
        names = {e.get("name") for e in (outputs.get("entities") or [])}
>       assert names == _EXPECTED_ENTITY_NAMES
E       AssertionError: assert set() == {'AnswerOptio...ldGroup', ...}
E         
E         Extra items in the right set:
E         'FieldGroup'
E         'QuestionToFieldGroup'
E         'Response'
E         'GeneratedDocument'
E         'Company'
E         'QuestionnaireQuestion'
E         'ResponseSet'
E         'GroupValue'
E         'AnswerOption'
E         
E         Full diff:
E         + set()
E         - {
E         -     'AnswerOption',
E         -     'Company',
E         -     'FieldGroup',
E         -     'GeneratedDocument',
E         -     'GroupValue',
E         -     'QuestionToFieldGroup',
E         -     'QuestionnaireQuestion',
E         -     'Response',
E         -     'ResponseSet',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2219: AssertionError
___________________ test_7_2_2_64_outputs_fields_set_invalid ___________________

    def test_7_2_2_64_outputs_fields_set_invalid():
        """Verifies 7.2.2.64  Outputs: fields set invalid."""
        outputs = _get_outputs_for_contract()
        resp = next((e for e in (outputs.get("entities") or []) if e.get("name") == "Response"), {})
        fields = {f.get("name"): f.get("type") for f in (resp.get("fields") or [])}
>       assert fields == {"response_id": "uuid", "response_set_id": "uuid", "question_id": "uuid", "value_json": "jsonb"}
E       AssertionError: assert {} == {'question_id...son': 'jsonb'}
E         
E         Right contains 4 more items:
E         {'question_id': 'uuid',
E          'response_id': 'uuid',
E          'response_set_id': 'uuid',
E          'value_json': 'jsonb'}
E         
E         Full diff:
E         + {}
E         - {
E         -     'question_id': 'uuid',
E         -     'response_id': 'uuid',
E         -     'response_set_id': 'uuid',
E         -     'value_json': 'jsonb',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2234: AssertionError
______________ test_7_2_2_67_outputs_field_name_mismatch_with_erd ______________

    def test_7_2_2_67_outputs_field_name_mismatch_with_erd():
        """Verifies 7.2.2.67  Outputs: field name mismatch with ERD."""
        outputs = _get_outputs_for_contract()
        resp = next((e for e in (outputs.get("entities") or []) if e.get("name") == "Response"), {})
        names = {f.get("name") for f in (resp.get("fields") or [])}
>       assert names == {"response_id", "response_set_id", "question_id", "value_json"}
E       AssertionError: assert set() == {'question_id... 'value_json'}
E         
E         Extra items in the right set:
E         'question_id'
E         'response_set_id'
E         'response_id'
E         'value_json'
E         
E         Full diff:
E         + set()
E         - {
E         -     'question_id',
E         -     'response_id',
E         -     'response_set_id',
E         -     'value_json',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2257: AssertionError
______________ test_7_2_2_70_outputs_field_type_mismatch_with_erd ______________

    def test_7_2_2_70_outputs_field_type_mismatch_with_erd():
        """Verifies 7.2.2.70  Outputs: field type mismatch with ERD."""
        outputs = _get_outputs_for_contract()
        resp = next((e for e in (outputs.get("entities") or []) if e.get("name") == "Response"), {})
        types = {f.get("name"): f.get("type") for f in (resp.get("fields") or [])}
>       assert types == {"response_id": "uuid", "response_set_id": "uuid", "question_id": "uuid", "value_json": "jsonb"}
E       AssertionError: assert {} == {'question_id...son': 'jsonb'}
E         
E         Right contains 4 more items:
E         {'question_id': 'uuid',
E          'response_id': 'uuid',
E          'response_set_id': 'uuid',
E          'value_json': 'jsonb'}
E         
E         Full diff:
E         + {}
E         - {
E         -     'question_id': 'uuid',
E         -     'response_id': 'uuid',
E         -     'response_set_id': 'uuid',
E         -     'value_json': 'jsonb',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2281: AssertionError
___________ test_7_2_2_72_outputs_encrypted_flag_false_when_required ___________

    def test_7_2_2_72_outputs_encrypted_flag_false_when_required():
        """Verifies 7.2.2.72  Outputs: encrypted flag false when required."""
        outputs = _get_outputs_for_contract()
        resp = next((e for e in (outputs.get("entities") or []) if e.get("name") == "Response"), {})
        fld = next((f for f in (resp.get("fields") or []) if f.get("name") == "value_json"), {})
>       assert fld.get("encrypted") is True
E       AssertionError: assert None is True
E        +  where None = <built-in method get of dict object at 0x7f9078b97e80>('encrypted')
E        +    where <built-in method get of dict object at 0x7f9078b97e80> = {}.get

tests/functional/test_epic_a_data_model_functional.py:2297: AssertionError
__________ test_7_2_2_78_primary_key_columns_missing_when_pk_defined ___________

    def test_7_2_2_78_primary_key_columns_missing_when_pk_defined():
        """Verifies 7.2.2.78  Primary Key Columns Missing When PK Defined."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one entity declares a primary_key
>       assert any(ent.get("primary_key") is not None for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_78_primary_key_columns_missing_when_pk_defined.<locals>.<genexpr> at 0x7f9078b41230>)

tests/functional/test_epic_a_data_model_functional.py:2347: AssertionError
____________________ test_7_2_2_79_foreign_keys_set_invalid ____________________

    def test_7_2_2_79_foreign_keys_set_invalid():
        """Verifies 7.2.2.79  Foreign Keys Set Invalid."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert presence of at least one foreign key overall
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_79_foreign_keys_set_invalid.<locals>.<genexpr> at 0x7f9078b42180>)

tests/functional/test_epic_a_data_model_functional.py:2359: AssertionError
______________ test_7_2_2_80_foreign_keys_order_not_deterministic ______________

    def test_7_2_2_80_foreign_keys_order_not_deterministic():
        """Verifies 7.2.2.80  Foreign Keys Order Not Deterministic."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure foreign keys exist before order/uniqueness checks
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_80_foreign_keys_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b42880>)

tests/functional/test_epic_a_data_model_functional.py:2374: AssertionError
_____________________ test_7_2_2_81_foreign_key_name_empty _____________________

    def test_7_2_2_81_foreign_key_name_empty():
        """Verifies 7.2.2.81  Foreign Key Name Empty."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one FK exists
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_81_foreign_key_name_empty.<locals>.<genexpr> at 0x7f9078b228f0>)

tests/functional/test_epic_a_data_model_functional.py:2386: AssertionError
__________________ test_7_2_2_82_foreign_key_name_not_unique ___________________

    def test_7_2_2_82_foreign_key_name_not_unique():
        """Verifies 7.2.2.82  Foreign Key Name Not Unique."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure foreign keys exist before uniqueness check
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_82_foreign_key_name_not_unique.<locals>.<genexpr> at 0x7f9078b22ea0>)

tests/functional/test_epic_a_data_model_functional.py:2397: AssertionError
____________ test_7_2_2_83_foreign_key_name_missing_when_fks_exist _____________

    def test_7_2_2_83_foreign_key_name_missing_when_fks_exist():
        """Verifies 7.2.2.83  Foreign Key Name Missing When FKs Exist."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one non-empty FK list exists
>       assert any(ent.get("foreign_keys") for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_83_foreign_key_name_missing_when_fks_exist.<locals>.<genexpr> at 0x7f9078b23450>)

tests/functional/test_epic_a_data_model_functional.py:2408: AssertionError
__________________ test_7_2_2_84_foreign_key_columns_unknown ___________________

    def test_7_2_2_84_foreign_key_columns_unknown():
        """Verifies 7.2.2.84  Foreign Key Columns Unknown."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert fields and fks are present prior to subset checks
>       assert any((ent.get("fields") and ent.get("foreign_keys")) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_84_foreign_key_columns_unknown.<locals>.<genexpr> at 0x7f9078b4a260>)

tests/functional/test_epic_a_data_model_functional.py:2421: AssertionError
__________ test_7_2_2_85_foreign_key_columns_order_not_deterministic ___________

    def test_7_2_2_85_foreign_key_columns_order_not_deterministic():
        """Verifies 7.2.2.85  Foreign Key Columns Order Not Deterministic."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one FK has columns before ordering assertion
>       assert any((fk.get("columns") or []) for ent in entities for fk in (ent.get("foreign_keys") or []))
E       assert False
E        +  where False = any(<generator object test_7_2_2_85_foreign_key_columns_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b4be60>)

tests/functional/test_epic_a_data_model_functional.py:2433: AssertionError
___________ test_7_2_2_86_foreign_key_columns_missing_when_fks_exist ___________

    def test_7_2_2_86_foreign_key_columns_missing_when_fks_exist():
        """Verifies 7.2.2.86  Foreign Key Columns Missing When FKs Exist."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure FKs exist before asserting columns presence
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_86_foreign_key_columns_missing_when_fks_exist.<locals>.<genexpr> at 0x7f9078b48120>)

tests/functional/test_epic_a_data_model_functional.py:2445: AssertionError
_____________ test_7_2_2_87_foreign_key_references_entity_missing ______________

    def test_7_2_2_87_foreign_key_references_entity_missing():
        """Verifies 7.2.2.87  Foreign Key References Entity Missing."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert entities and fks exist prior to reference checks
>       assert entities
E       assert []

tests/functional/test_epic_a_data_model_functional.py:2456: AssertionError
_____________ test_7_2_2_88_foreign_key_references_columns_missing _____________

    def test_7_2_2_88_foreign_key_references_columns_missing():
        """Verifies 7.2.2.88  Foreign Key References Columns Missing."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one FK exists and references populated
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_88_foreign_key_references_columns_missing.<locals>.<genexpr> at 0x7f9078a58190>)

tests/functional/test_epic_a_data_model_functional.py:2469: AssertionError
_____________ test_7_2_2_89_foreign_key_references_entity_unknown ______________

    def test_7_2_2_89_foreign_key_references_entity_unknown():
        """Verifies 7.2.2.89  Foreign Key References Entity Unknown."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert entities and fks exist prior to membership checks
>       assert entities
E       assert []

tests/functional/test_epic_a_data_model_functional.py:2481: AssertionError
_____________ test_7_2_2_90_foreign_key_references_columns_unknown _____________

    def test_7_2_2_90_foreign_key_references_columns_unknown():
        """Verifies 7.2.2.90  Foreign Key References Columns Unknown."""
        outputs = _get_outputs_for_contract()
        # This requires cross-entity column validation; ensure presence first
        entities = (outputs.get("entities") or [])
>       assert any((ent.get("foreign_keys") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_90_foreign_key_references_columns_unknown.<locals>.<genexpr> at 0x7f9078b42f80>)

tests/functional/test_epic_a_data_model_functional.py:2494: AssertionError
_________ test_7_2_2_91_foreign_key_references_columns_count_mismatch __________

    def test_7_2_2_91_foreign_key_references_columns_count_mismatch():
        """Verifies 7.2.2.91  Foreign Key References Columns Count Mismatch."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert both fk and referenced columns exist before length compare
>       assert any((fk.get("columns") and (fk.get("references") or {}).get("columns"))
                   for ent in entities for fk in (ent.get("foreign_keys") or []))
E       assert False
E        +  where False = any(<generator object test_7_2_2_91_foreign_key_references_columns_count_mismatch.<locals>.<genexpr> at 0x7f9078b437d0>)

tests/functional/test_epic_a_data_model_functional.py:2506: AssertionError
_________________ test_7_2_2_92_unique_constraints_set_invalid _________________

    def test_7_2_2_92_unique_constraints_set_invalid():
        """Verifies 7.2.2.92  Unique Constraints Set Invalid."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert unique_constraints exist before inner structure checks
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_92_unique_constraints_set_invalid.<locals>.<genexpr> at 0x7f9078b238b0>)

tests/functional/test_epic_a_data_model_functional.py:2520: AssertionError
___________ test_7_2_2_93_unique_constraints_order_not_deterministic ___________

    def test_7_2_2_93_unique_constraints_order_not_deterministic():
        """Verifies 7.2.2.93  Unique Constraints Order Not Deterministic."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure unique constraints exist before order check
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_93_unique_constraints_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b206d0>)

tests/functional/test_epic_a_data_model_functional.py:2532: AssertionError
__________________ test_7_2_2_94_unique_constraint_name_empty __________________

    def test_7_2_2_94_unique_constraint_name_empty():
        """Verifies 7.2.2.94  Unique Constraint Name Empty."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure unique constraints exist before name checks
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_94_unique_constraint_name_empty.<locals>.<genexpr> at 0x7f9078b20ac0>)

tests/functional/test_epic_a_data_model_functional.py:2543: AssertionError
_______________ test_7_2_2_95_unique_constraint_name_not_unique ________________

    def test_7_2_2_95_unique_constraint_name_not_unique():
        """Verifies 7.2.2.95  Unique Constraint Name Not Unique."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure unique constraints exist before uniqueness check
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_95_unique_constraint_name_not_unique.<locals>.<genexpr> at 0x7f9078b48b30>)

tests/functional/test_epic_a_data_model_functional.py:2554: AssertionError
_______ test_7_2_2_96_unique_constraint_name_missing_when_uniques_exist ________

    def test_7_2_2_96_unique_constraint_name_missing_when_uniques_exist():
        """Verifies 7.2.2.96  Unique Constraint Name Missing When Uniques Exist."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure at least one entity exposes unique_constraints
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_96_unique_constraint_name_missing_when_uniques_exist.<locals>.<genexpr> at 0x7f9078b4bd80>)

tests/functional/test_epic_a_data_model_functional.py:2565: AssertionError
_______________ test_7_2_2_97_unique_constraint_columns_unknown ________________

    def test_7_2_2_97_unique_constraint_columns_unknown():
        """Verifies 7.2.2.97  Unique Constraint Columns Unknown."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: assert fields and unique_constraints exist before subset checks
>       assert any((ent.get("fields") and ent.get("unique_constraints")) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_97_unique_constraint_columns_unknown.<locals>.<genexpr> at 0x7f9078bebd10>)

tests/functional/test_epic_a_data_model_functional.py:2578: AssertionError
_______ test_7_2_2_98_unique_constraint_columns_order_not_deterministic ________

    def test_7_2_2_98_unique_constraint_columns_order_not_deterministic():
        """Verifies 7.2.2.98  Unique Constraint Columns Order Not Deterministic."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure columns exist before ordering assert
>       assert any((uq.get("columns") or []) for ent in entities for uq in (ent.get("unique_constraints") or []))
E       assert False
E        +  where False = any(<generator object test_7_2_2_98_unique_constraint_columns_order_not_deterministic.<locals>.<genexpr> at 0x7f9078a5bbc0>)

tests/functional/test_epic_a_data_model_functional.py:2590: AssertionError
______ test_7_2_2_99_unique_constraint_columns_missing_when_uniques_exist ______

    def test_7_2_2_99_unique_constraint_columns_missing_when_uniques_exist():
        """Verifies 7.2.2.99  Unique Constraint Columns Missing When Uniques Exist."""
        outputs = _get_outputs_for_contract()
        entities = (outputs.get("entities") or [])
        # Clarke: ensure unique constraints exist before asserting columns presence
>       assert any((ent.get("unique_constraints") or []) for ent in entities)
E       assert False
E        +  where False = any(<generator object test_7_2_2_99_unique_constraint_columns_missing_when_uniques_exist.<locals>.<genexpr> at 0x7f9078b435a0>)

tests/functional/test_epic_a_data_model_functional.py:2602: AssertionError
_______________________ test_7_2_2_108_enums_incomplete ________________________

    def test_7_2_2_108_enums_incomplete():
        """Verifies 7.2.2.108  Enums Incomplete."""
        outputs = _get_outputs_for_contract()
        enums = outputs.get("enums") or []
        ak = next((e for e in enums if e.get("name") == "answer_kind"), None)
>       assert ak is not None and ak.get("values") == ["boolean", "enum_single", "long_text", "number", "short_string"]
E       assert (None is not None)

tests/functional/test_epic_a_data_model_functional.py:2682: AssertionError
__________________ test_7_2_2_111_enum_name_mismatch_with_erd __________________

    def test_7_2_2_111_enum_name_mismatch_with_erd():
        """Verifies 7.2.2.111  Enum Name Mismatch With ERD."""
        outputs = _get_outputs_for_contract()
        names = {e.get("name") for e in (outputs.get("enums") or [])}
>       assert {"answer_kind"}.issubset(names)
E       AssertionError: assert False
E        +  where False = <built-in method issubset of set object at 0x7f9079dbaf80>(set())
E        +    where <built-in method issubset of set object at 0x7f9079dbaf80> = {'answer_kind'}.issubset

tests/functional/test_epic_a_data_model_functional.py:2704: AssertionError
_________________ test_7_2_2_114_enum_values_mismatch_with_erd _________________

    def test_7_2_2_114_enum_values_mismatch_with_erd():
        """Verifies 7.2.2.114  Enum Values Mismatch With ERD."""
        outputs = _get_outputs_for_contract()
        ak = next((e for e in (outputs.get("enums") or []) if e.get("name") == "answer_kind"), {})
>       assert set(ak.get("values") or []) == {"boolean", "enum_single", "long_text", "number", "short_string"}
E       AssertionError: assert set() == {'boolean', '...short_string'}
E         
E         Extra items in the right set:
E         'boolean'
E         'enum_single'
E         'number'
E         'short_string'
E         'long_text'
E         
E         Full diff:
E         + set()
E         - {
E         -     'boolean',
E         -     'enum_single',
E         -     'long_text',
E         -     'number',
E         -     'short_string',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2727: AssertionError
__________________ test_7_2_2_117_encrypted_fields_incomplete __________________

    def test_7_2_2_117_encrypted_fields_incomplete():
        """Verifies 7.2.2.117  Encrypted Fields Incomplete."""
        outputs = _get_outputs_for_contract()
        manifest = set(outputs.get("encrypted_fields") or [])
        expected = {"Company.legal_name", "Company.registered_office_address", "Response.value_json", "GeneratedDocument.output_uri"}
>       assert manifest == expected
E       AssertionError: assert set() == {'Company.leg...e.value_json'}
E         
E         Extra items in the right set:
E         'Company.legal_name'
E         'Company.registered_office_address'
E         'GeneratedDocument.output_uri'
E         'Response.value_json'
E         
E         Full diff:
E         + set()
E         - {
E         -     'Company.legal_name',
E         -     'Company.registered_office_address',
E         -     'GeneratedDocument.output_uri',
E         -     'Response.value_json',
E         - }

tests/functional/test_epic_a_data_model_functional.py:2750: AssertionError
________________ test_7_2_2_120_constraints_applied_incomplete _________________

    def test_7_2_2_120_constraints_applied_incomplete():
        """Verifies 7.2.2.120  Constraints Applied Incomplete."""
        outputs = _get_outputs_for_contract()
        constraints = set(outputs.get("constraints_applied") or [])
        required = {"pk_response", "fk_response_set", "uq_response_set_question"}
>       assert required.issubset(constraints)
E       AssertionError: assert False
E        +  where False = <built-in method issubset of set object at 0x7f9078bf3a00>(set())
E        +    where <built-in method issubset of set object at 0x7f9078bf3a00> = {'fk_response_set', 'pk_response', 'uq_response_set_question'}.issubset

tests/functional/test_epic_a_data_model_functional.py:2772: AssertionError
____________________ test_7_2_2_124_migration_journal_empty ____________________

    def test_7_2_2_124_migration_journal_empty():
        """Verifies 7.2.2.124  Migration Journal Empty."""
        outputs = _get_outputs_for_contract()
>       assert (outputs.get("migration_journal") or [])
E       AssertionError: assert (None or [])
E        +  where None = <built-in method get of dict object at 0x7f9078e3bd40>('migration_journal')
E        +    where <built-in method get of dict object at 0x7f9078e3bd40> = {}.get

tests/functional/test_epic_a_data_model_functional.py:2799: AssertionError
=========================== short test summary info ============================
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_22_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078cb8e80>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078cb8e80> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_23_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078b9c640>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078b9c640> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_24_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078c22cc0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078c22cc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_25_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078fbf0c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078fbf0c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_26_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f90793cb4c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f90793cb4c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_27_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079a5ac40>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079a5ac40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_28_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078c44ac0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078c44ac0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_29_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078a0b400>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078a0b400> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_30_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f90789ee9c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f90789ee9c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_31_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078d27280>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078d27280> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_32_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078d37b00>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078d37b00> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_33_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078b9c840>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078b9c840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_34_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078edc800>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078edc800> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_35_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078a8b840>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078a8b840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_36_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f90794724c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f90794724c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_37_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078b74bc0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078b74bc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_38_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079a34040>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079a34040> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_39_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078a0abc0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078a0abc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_40_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079c40400>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079c40400> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_41_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f90789a6e00>('exit_code')
 +    where <built-in method get of dict object at 0x7f90789a6e00> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_42_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078d37c80>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078d37c80> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_43_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079625e40>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079625e40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_44_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f907931c080>('exit_code')
 +    where <built-in method get of dict object at 0x7f907931c080> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_45_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078a21fc0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078a21fc0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_46_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078b18e40>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078b18e40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_47_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078977980>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078977980> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_48_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079dc1480>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079dc1480> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_49_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078bd0840>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078bd0840> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_50_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078c2f680>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078c2f680> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_51_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078ba82c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078ba82c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_52_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079a297c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079a297c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_53_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f90789e3100>('exit_code')
 +    where <built-in method get of dict object at 0x7f90789e3100> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_54_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078a0de40>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078a0de40> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_55_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078eba440>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078eba440> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_56_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9079c409c0>('exit_code')
 +    where <built-in method get of dict object at 0x7f9079c409c0> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_57_enhanced_error_semantics - AssertionError: assert None == 1
 +  where None = <built-in method get of dict object at 0x7f9078e9e100>('exit_code')
 +    where <built-in method get of dict object at 0x7f9078e9e100> = {'context': {}, 'error': {'code': 'EXPECTED_ERROR_CODE_FROM_SPEC'}, 'events': [], 'exit_code': None, ...}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_58_outputs_entities_incomplete - assert None is not None
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_60_outputs_entities_mutable_within_step - assert ({})
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_62_outputs_entity_name_mismatch_with_erd - AssertionError: assert set() == {'AnswerOptio...ldGroup', ...}
  
  Extra items in the right set:
  'FieldGroup'
  'QuestionToFieldGroup'
  'Response'
  'GeneratedDocument'
  'Company'
  'QuestionnaireQuestion'
  'ResponseSet'
  'GroupValue'
  'AnswerOption'
  
  Full diff:
  + set()
  - {
  -     'AnswerOption',
  -     'Company',
  -     'FieldGroup',
  -     'GeneratedDocument',
  -     'GroupValue',
  -     'QuestionToFieldGroup',
  -     'QuestionnaireQuestion',
  -     'Response',
  -     'ResponseSet',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_64_outputs_fields_set_invalid - AssertionError: assert {} == {'question_id...son': 'jsonb'}
  
  Right contains 4 more items:
  {'question_id': 'uuid',
   'response_id': 'uuid',
   'response_set_id': 'uuid',
   'value_json': 'jsonb'}
  
  Full diff:
  + {}
  - {
  -     'question_id': 'uuid',
  -     'response_id': 'uuid',
  -     'response_set_id': 'uuid',
  -     'value_json': 'jsonb',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_67_outputs_field_name_mismatch_with_erd - AssertionError: assert set() == {'question_id... 'value_json'}
  
  Extra items in the right set:
  'question_id'
  'response_set_id'
  'response_id'
  'value_json'
  
  Full diff:
  + set()
  - {
  -     'question_id',
  -     'response_id',
  -     'response_set_id',
  -     'value_json',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_70_outputs_field_type_mismatch_with_erd - AssertionError: assert {} == {'question_id...son': 'jsonb'}
  
  Right contains 4 more items:
  {'question_id': 'uuid',
   'response_id': 'uuid',
   'response_set_id': 'uuid',
   'value_json': 'jsonb'}
  
  Full diff:
  + {}
  - {
  -     'question_id': 'uuid',
  -     'response_id': 'uuid',
  -     'response_set_id': 'uuid',
  -     'value_json': 'jsonb',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_72_outputs_encrypted_flag_false_when_required - AssertionError: assert None is True
 +  where None = <built-in method get of dict object at 0x7f9078b97e80>('encrypted')
 +    where <built-in method get of dict object at 0x7f9078b97e80> = {}.get
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_78_primary_key_columns_missing_when_pk_defined - assert False
 +  where False = any(<generator object test_7_2_2_78_primary_key_columns_missing_when_pk_defined.<locals>.<genexpr> at 0x7f9078b41230>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_79_foreign_keys_set_invalid - assert False
 +  where False = any(<generator object test_7_2_2_79_foreign_keys_set_invalid.<locals>.<genexpr> at 0x7f9078b42180>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_80_foreign_keys_order_not_deterministic - assert False
 +  where False = any(<generator object test_7_2_2_80_foreign_keys_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b42880>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_81_foreign_key_name_empty - assert False
 +  where False = any(<generator object test_7_2_2_81_foreign_key_name_empty.<locals>.<genexpr> at 0x7f9078b228f0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_82_foreign_key_name_not_unique - assert False
 +  where False = any(<generator object test_7_2_2_82_foreign_key_name_not_unique.<locals>.<genexpr> at 0x7f9078b22ea0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_83_foreign_key_name_missing_when_fks_exist - assert False
 +  where False = any(<generator object test_7_2_2_83_foreign_key_name_missing_when_fks_exist.<locals>.<genexpr> at 0x7f9078b23450>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_84_foreign_key_columns_unknown - assert False
 +  where False = any(<generator object test_7_2_2_84_foreign_key_columns_unknown.<locals>.<genexpr> at 0x7f9078b4a260>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_85_foreign_key_columns_order_not_deterministic - assert False
 +  where False = any(<generator object test_7_2_2_85_foreign_key_columns_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b4be60>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_86_foreign_key_columns_missing_when_fks_exist - assert False
 +  where False = any(<generator object test_7_2_2_86_foreign_key_columns_missing_when_fks_exist.<locals>.<genexpr> at 0x7f9078b48120>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_87_foreign_key_references_entity_missing - assert []
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_88_foreign_key_references_columns_missing - assert False
 +  where False = any(<generator object test_7_2_2_88_foreign_key_references_columns_missing.<locals>.<genexpr> at 0x7f9078a58190>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_89_foreign_key_references_entity_unknown - assert []
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_90_foreign_key_references_columns_unknown - assert False
 +  where False = any(<generator object test_7_2_2_90_foreign_key_references_columns_unknown.<locals>.<genexpr> at 0x7f9078b42f80>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_91_foreign_key_references_columns_count_mismatch - assert False
 +  where False = any(<generator object test_7_2_2_91_foreign_key_references_columns_count_mismatch.<locals>.<genexpr> at 0x7f9078b437d0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_92_unique_constraints_set_invalid - assert False
 +  where False = any(<generator object test_7_2_2_92_unique_constraints_set_invalid.<locals>.<genexpr> at 0x7f9078b238b0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_93_unique_constraints_order_not_deterministic - assert False
 +  where False = any(<generator object test_7_2_2_93_unique_constraints_order_not_deterministic.<locals>.<genexpr> at 0x7f9078b206d0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_94_unique_constraint_name_empty - assert False
 +  where False = any(<generator object test_7_2_2_94_unique_constraint_name_empty.<locals>.<genexpr> at 0x7f9078b20ac0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_95_unique_constraint_name_not_unique - assert False
 +  where False = any(<generator object test_7_2_2_95_unique_constraint_name_not_unique.<locals>.<genexpr> at 0x7f9078b48b30>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_96_unique_constraint_name_missing_when_uniques_exist - assert False
 +  where False = any(<generator object test_7_2_2_96_unique_constraint_name_missing_when_uniques_exist.<locals>.<genexpr> at 0x7f9078b4bd80>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_97_unique_constraint_columns_unknown - assert False
 +  where False = any(<generator object test_7_2_2_97_unique_constraint_columns_unknown.<locals>.<genexpr> at 0x7f9078bebd10>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_98_unique_constraint_columns_order_not_deterministic - assert False
 +  where False = any(<generator object test_7_2_2_98_unique_constraint_columns_order_not_deterministic.<locals>.<genexpr> at 0x7f9078a5bbc0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_99_unique_constraint_columns_missing_when_uniques_exist - assert False
 +  where False = any(<generator object test_7_2_2_99_unique_constraint_columns_missing_when_uniques_exist.<locals>.<genexpr> at 0x7f9078b435a0>)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_108_enums_incomplete - assert (None is not None)
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_111_enum_name_mismatch_with_erd - AssertionError: assert False
 +  where False = <built-in method issubset of set object at 0x7f9079dbaf80>(set())
 +    where <built-in method issubset of set object at 0x7f9079dbaf80> = {'answer_kind'}.issubset
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_114_enum_values_mismatch_with_erd - AssertionError: assert set() == {'boolean', '...short_string'}
  
  Extra items in the right set:
  'boolean'
  'enum_single'
  'number'
  'short_string'
  'long_text'
  
  Full diff:
  + set()
  - {
  -     'boolean',
  -     'enum_single',
  -     'long_text',
  -     'number',
  -     'short_string',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_117_encrypted_fields_incomplete - AssertionError: assert set() == {'Company.leg...e.value_json'}
  
  Extra items in the right set:
  'Company.legal_name'
  'Company.registered_office_address'
  'GeneratedDocument.output_uri'
  'Response.value_json'
  
  Full diff:
  + set()
  - {
  -     'Company.legal_name',
  -     'Company.registered_office_address',
  -     'GeneratedDocument.output_uri',
  -     'Response.value_json',
  - }
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_120_constraints_applied_incomplete - AssertionError: assert False
 +  where False = <built-in method issubset of set object at 0x7f9078bf3a00>(set())
 +    where <built-in method issubset of set object at 0x7f9078bf3a00> = {'fk_response_set', 'pk_response', 'uq_response_set_question'}.issubset
FAILED tests/functional/test_epic_a_data_model_functional.py::test_7_2_2_124_migration_journal_empty - AssertionError: assert (None or [])
 +  where None = <built-in method get of dict object at 0x7f9078e3bd40>('migration_journal')
 +    where <built-in method get of dict object at 0x7f9078e3bd40> = {}.get
================== 71 failed, 118 passed, 1 xfailed in 8.64s ===================
